# Implementation Plan: ERPNext Claude Chatbot

**Branch**: `001-erpnext-claude-chatbot` | **Date**: 2025-12-29 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-erpnext-claude-chatbot/spec.md`

**Note**: This file is generated by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build an AI-powered chatbot within ERPNext that enables natural language queries for financial and business data. The system uses the OpenAI Agent SDK for orchestration, Gemini 2.5 Flash for language processing (via OpenAI-compatible endpoint), and strictly enforces ERPNext permissions through Frappe APIs and standard reports. All chat interactions are session-isolated, audited, and stored in dedicated DocTypes separate from transactional data.

**Primary Requirement**: Enable finance managers and sales personnel to query ERP data using natural language while maintaining complete security, auditability, and data integrity per constitutional principles.

**Technical Approach**: Implement as a custom Frappe app that extends ERPNext with custom DocTypes for chat management, Python backend services for agent orchestration and tool execution, and a JavaScript-based UI widget integrated into ERPNext's interface.

## Technical Context

**Language/Version**: Python 3.10+ (Frappe Framework requirement)
**Primary Dependencies**:
- Frappe Framework 15.x / ERPNext 15.x
- OpenAI Agent SDK (Python client)
- OpenAI-compatible API client for Gemini 2.5 Flash
- Frappe REST API and Report Builder

**Storage**: MariaDB/PostgreSQL (via Frappe ORM - DocTypes for Chat Session, Chat Message, Chat Audit Log, AI Tool Call Log)
**Testing**:
- unittest/pytest (Python backend testing)
- Frappe test framework for DocType and API testing
- Contract testing for AI tool definitions

**Target Platform**: Linux server (Ubuntu 20.04+/Debian 11+) running ERPNext instance
**Project Type**: Custom Frappe App (extends ERPNext with new DocTypes, API endpoints, and UI components)

**Performance Goals**:
- p95 latency < 5 seconds for simple queries (single report, single company)
- p95 latency < 15 seconds for complex multi-step queries
- Support 50 concurrent chat sessions without degradation
- Token usage optimization (<2000 tokens per simple query)

**Constraints**:
- MUST use Frappe APIs exclusively (no direct database queries)
- MUST respect ERPNext role-based permissions at every API call
- MUST maintain session isolation (no cross-user data leakage)
- MUST audit log all AI operations with user/timestamp/data-accessed
- Rate limit: 20 queries per minute per user
- Resource cap: <20% system resources under normal load

**Scale/Scope**:
- Initial deployment: 10-50 concurrent users
- Chat history retention: 90 days (configurable)
- Supported ERPNext modules: Accounts, Selling (extensible to other modules in future)
- Read-only operations (no document creation/updates via chatbot)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Database Access Isolation ✅ PASS
- **Requirement**: AI must never directly access ERP database
- **Compliance**: All data access through Frappe `frappe.get_doc()`, `frappe.get_list()`, and Report API
- **Validation**: No SQL queries in agent tools; all tools call Frappe methods with permission checks

### Principle II: API-First Data Access ✅ PASS
- **Requirement**: All ERP data access via Frappe APIs or standard ERPNext reports
- **Compliance**: Agent tools implemented as Python functions calling:
  - `frappe.call()` for REST API endpoints
  - `frappe.desk.query_report.run()` for standard reports
  - Frappe ORM methods (`get_doc`, `get_list`) with permission validation
- **Validation**: No direct ORM queries bypassing permissions; all access logged

### Principle III: OpenAI Agent SDK for Orchestration ✅ PASS
- **Requirement**: Use OpenAI Agent SDK for orchestration and tool calling
- **Compliance**: Agent instantiated using `openai.agents.Agent` class
- **Validation**: Tool definitions registered via SDK's tool registration mechanism

### Principle IV: Gemini 2.5 Flash via OpenAI-Compatible Endpoint ✅ PASS
- **Requirement**: Gemini 2.5 Flash accessed via OpenAI-compatible endpoint
- **Compliance**: OpenAI client configured with custom `base_url` pointing to Gemini-compatible endpoint
- **Validation**: API key and endpoint stored in Site Config (`site_config.json` encrypted fields)

### Principle V: Session Isolation ✅ PASS
- **Requirement**: Each chat isolated with unique session ID
- **Compliance**:
  - New session created with UUID on first message
  - Session linked to `frappe.session.user`
  - Context loaded only from current session's messages
- **Validation**: Session ownership validated before every message load/save

### Principle VI: Dedicated Storage for Chat History ✅ PASS
- **Requirement**: Chat data in dedicated DocTypes, separate from transactional data
- **Compliance**:
  - Custom DocTypes: `Chat Session`, `Chat Message`, `Chat Audit Log`, `AI Tool Call Log`
  - No foreign keys to transactional DocTypes (Sales Invoice, Customer, etc.)
- **Validation**: DocType definitions include clear separation markers in schema

### Principle VII: Single Source of Truth ✅ PASS
- **Requirement**: ERPNext is sole source of truth; chatbot is read interface
- **Compliance**:
  - All agent tools query ERPNext data (never create/update)
  - No caching of business data (only session context)
- **Validation**: Tool definitions marked as read-only; no write operations permitted

### Principle VIII: Deterministic and Auditable Operations ✅ PASS
- **Requirement**: All AI operations logged for compliance audits
- **Compliance**:
  - `Chat Audit Log` DocType captures: user, timestamp, query, response summary, data accessed
  - `AI Tool Call Log` captures: tool name, parameters, execution time, results, errors
- **Validation**: Audit log creation in exception-safe transaction (logged even if query fails)

### Principle IX: Role-Based Access Control ✅ PASS
- **Requirement**: Enforce RBAC at every step; never bypass permissions
- **Compliance**:
  - Every tool call wraps data access with `frappe.has_permission()` check
  - Company restrictions enforced via `frappe.defaults.get_user_default('Company')`
  - Report execution respects report-level permissions
- **Validation**: Permission test suite validates unauthorized access blocked 100% of cases

### Principle X: Production-Grade Standards ✅ PASS
- **Requirement**: Follow Frappe conventions, error handling, extensibility
- **Compliance**:
  - App structure follows Frappe's standard app template (`frappe_app_name/hooks.py`, `modules/`, `public/`)
  - Python type hints for all functions
  - Comprehensive error handling with user-friendly messages
  - Docstrings (Google style) for all public APIs
- **Validation**: Code review checklist includes convention compliance, <10 cyclomatic complexity

**Constitution Check Result**: ✅ ALL GATES PASSED - Proceed to Phase 0 Research

## Project Structure

### Documentation (this feature)

```text
specs/001-erpnext-claude-chatbot/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
│   ├── agent-tools.md   # AI tool definitions (tool calling schema)
│   ├── api-endpoints.md # Frappe API endpoints for chatbot
│   └── doctypes.md      # DocType field schemas
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

This feature implements as a **custom Frappe app** following Frappe's standard app structure:

```text
# Custom Frappe App: erpnext_chatbot
erpnext_chatbot/
├── erpnext_chatbot/           # Main app module
│   ├── __init__.py
│   ├── hooks.py               # Frappe hooks (UI integration, scheduled jobs)
│   ├── modules.txt            # ERPNext module registration
│   │
│   ├── ai_chatbot/            # Custom module for chatbot functionality
│   │   ├── doctype/           # DocType definitions
│   │   │   ├── chat_session/
│   │   │   │   ├── chat_session.json
│   │   │   │   ├── chat_session.py
│   │   │   │   └── test_chat_session.py
│   │   │   ├── chat_message/
│   │   │   │   ├── chat_message.json
│   │   │   │   ├── chat_message.py
│   │   │   │   └── test_chat_message.py
│   │   │   ├── chat_audit_log/
│   │   │   │   ├── chat_audit_log.json
│   │   │   │   └── chat_audit_log.py
│   │   │   └── ai_tool_call_log/
│   │   │       ├── ai_tool_call_log.json
│   │   │       └── ai_tool_call_log.py
│   │   │
│   │   ├── page/              # Custom ERPNext pages (UI)
│   │   │   └── chatbot/
│   │   │       ├── chatbot.json
│   │   │       ├── chatbot.js
│   │   │       ├── chatbot.html
│   │   │       └── chatbot.py
│   │   │
│   │   └── api/               # API endpoints
│   │       ├── __init__.py
│   │       ├── chat.py        # Chat session management API
│   │       └── agent.py       # Agent orchestration API
│   │
│   ├── services/              # Business logic services
│   │   ├── __init__.py
│   │   ├── agent_orchestrator.py    # OpenAI Agent SDK integration
│   │   ├── session_manager.py       # Session lifecycle management
│   │   ├── audit_logger.py          # Audit logging service
│   │   └── rate_limiter.py          # Rate limiting service
│   │
│   ├── tools/                 # AI agent tools (ERP data access)
│   │   ├── __init__.py
│   │   ├── base_tool.py       # Base class with permission checking
│   │   ├── finance_tools.py   # Financial data queries (P&L, revenue, expenses)
│   │   ├── sales_tools.py     # Sales and customer queries
│   │   └── report_tools.py    # Generic ERPNext report execution
│   │
│   ├── utils/                 # Utility functions
│   │   ├── __init__.py
│   │   ├── permissions.py     # Permission validation helpers
│   │   ├── sanitization.py    # Input sanitization
│   │   └── response_formatter.py  # Format ERP data for AI consumption
│   │
│   ├── config/                # App configuration
│   │   ├── __init__.py
│   │   └── desktop.py         # Desktop icon configuration
│   │
│   └── public/                # Static assets
│       ├── css/
│       │   └── chatbot.css
│       └── js/
│           └── chatbot_widget.js
│
├── tests/                     # Test suite
│   ├── unit/                  # Unit tests for services and tools
│   ├── integration/           # API and DocType integration tests
│   ├── contract/              # AI tool contract tests
│   └── permission/            # Permission enforcement tests
│
├── requirements.txt           # Python dependencies (OpenAI Agent SDK, etc.)
├── setup.py                   # Frappe app installation script
├── license.txt
└── README.md
```

**Structure Decision**:

This is a **Custom Frappe App** structure (Frappe's standard extension pattern for ERPNext).

**Rationale**:
- Frappe apps are the standard way to extend ERPNext functionality
- Provides clean separation from core ERPNext code
- Enables version control, testing, and deployment as independent module
- Follows Frappe's conventions for DocTypes, Pages, APIs, and Hooks
- Supports installation via `bench get-app` and `bench install-app`

**Key directories**:
- `doctype/`: Custom DocTypes for chat data (managed via Frappe's ORM)
- `page/`: Custom ERPNext page for chatbot UI
- `api/`: Whitelisted API endpoints (decorated with `@frappe.whitelist()`)
- `services/`: Business logic layer (agent orchestration, session management)
- `tools/`: AI agent tools that call Frappe APIs with permission checks
- `public/`: JavaScript and CSS assets bundled by Frappe's build system

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No violations detected** - All constitutional principles satisfied by the proposed architecture.

## Phase 0: Research & Technology Decisions

*Note: This section will be expanded in research.md*

### Research Questions to Address

1. **OpenAI Agent SDK Integration with Gemini**
   - How to configure OpenAI Python client with custom `base_url` for Gemini-compatible endpoint?
   - Does Gemini 2.5 Flash support function calling (required for tool usage)?
   - Token limits and context window for Gemini 2.5 Flash?

2. **Frappe API Best Practices**
   - Standard patterns for permission-checked data access (`frappe.has_permission()` usage)?
   - How to execute ERPNext standard reports programmatically with filters?
   - Best practices for whitelisted API endpoints (`@frappe.whitelist()` decorator patterns)?

3. **Session Management in Frappe**
   - How to store session state securely (UUID generation, user linking)?
   - Session expiry patterns in Frappe (scheduled jobs for cleanup)?
   - Handling concurrent session access (locking/transactions)?

4. **Rate Limiting in Frappe**
   - Frappe's built-in rate limiting mechanisms?
   - Custom rate limiter implementation patterns (Redis vs. database)?

5. **UI Integration Patterns**
   - How to add custom pages to ERPNext navigation?
   - JavaScript patterns for real-time chat UI in Frappe?
   - WebSocket vs. polling for chat message updates?

6. **Testing Strategy**
   - Frappe's test framework conventions (test case structure)?
   - Mocking Frappe API calls in unit tests?
   - Permission testing patterns?

### Technology Decisions Summary

*(Detailed findings in research.md after Phase 0 completion)*

- **Agent SDK**: OpenAI Python client v1.x configured with `base_url` for Gemini endpoint
- **Session Storage**: Frappe DocType (`Chat Session`) with UUID primary key, linked to `frappe.session.user`
- **Permission Enforcement**: Wrapper function for all tool calls validating `frappe.has_permission(doctype, user)`
- **Rate Limiting**: Custom decorator using Frappe Cache (Redis-backed) for per-user request counting
- **UI Pattern**: Custom Frappe Page with JavaScript-based chat interface, polling API for messages
- **Testing**: Frappe's `unittest` framework with `frappe.set_user()` for permission testing

## Phase 1: Design Artifacts

*Note: Detailed artifacts generated in separate files*

### Data Model (`data-model.md`)

Key entities to define:
- **Chat Session**: session_id (UUID), user (link), status, created_at, last_activity, company_context
- **Chat Message**: message_id, session_id (link), role (user/assistant), content, timestamp, token_count
- **Chat Audit Log**: audit_id, session_id (link), user, query_text, response_summary, data_accessed (JSON), timestamp
- **AI Tool Call Log**: log_id, session_id (link), tool_name, parameters (JSON), execution_time, result_status, errors

### API Contracts (`contracts/`)

Key endpoints and tool definitions:
- **POST /api/method/erpnext_chatbot.api.chat.create_session**: Create new chat session
- **POST /api/method/erpnext_chatbot.api.chat.send_message**: Send user message and get AI response
- **GET /api/method/erpnext_chatbot.api.chat.get_session_history**: Retrieve session messages
- **POST /api/method/erpnext_chatbot.api.chat.delete_session**: Delete chat session

Agent tool definitions (OpenAI function calling schema):
- `get_financial_report(report_name, filters, company)`: Execute ERPNext financial reports
- `query_customers(filters, fields)`: Query customer data with permissions
- `get_sales_data(start_date, end_date, company)`: Retrieve sales metrics

### Quickstart Guide (`quickstart.md`)

Development setup instructions:
1. Install ERPNext development environment (bench setup)
2. Create custom app: `bench new-app erpnext_chatbot`
3. Install dependencies: `pip install openai`
4. Configure Gemini API credentials in Site Config
5. Install app: `bench install-app erpnext_chatbot`
6. Run migrations: `bench migrate`
7. Run tests: `bench run-tests --app erpnext_chatbot`

## Next Steps

After `/sp.plan` completion:
1. Review generated artifacts: `research.md`, `data-model.md`, `contracts/`, `quickstart.md`
2. Run `/sp.tasks` to generate implementation task list
3. Begin implementation following constitutional principles

**Critical Path**: Phase 2 (Session & Storage) → Phase 3 (Agent Layer) → Phase 4 (ERP Integration) must be sequential due to dependencies. Phase 5 (UI) and Phase 6 (Governance) can proceed in parallel once Phase 4 completes.
